# 5. 책임과 메시지

책임은 너무 구체적인 것도 좋지 않지만, 너무 추상적인 것도 좋지 않다.

자율적인 책임의 특징은 객체가 어떻게 해야하는 가가 아니라 무엇을 해야 하는가를 설명한다는 것이다.

객체가 수신할 수 있는 ‘메시지’와 메시지를 처리하기 위해 선택할 수 있는 ‘방법’이라는 두 가지 개념이 존재한다. 객체는 메시지를 받으면 해당 메시지를 처리할 수 있는지 여부를 확인한다. 그 후 처리할 수 있다고 판단하면 메시지를 처리할 방법인 메소드를 선택한다. 메시지는 어떻게 수행될 것인지는 명시하지 않는다. 메시지는 ‘무엇’이 실행되기를 바라는지만 명시하고, 어떤 메소드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다. 메시지를 수신한 객체가 런타임에 메소드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분짓는 핵심적인 특징 중 하나이다. (자바의 리플렉션과 연관지을 수 있는듯)

다형성은 객체들의 대체 가능성을 이용해서 설계를 유연하고 재사용 가능하게 만든다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. 즉, 다형성은 수신자의 종류를 캡슐화한다. 왕은 ‘증언하라’라는 메시지를 전송하지만 메시지를 수신하는 대상이 모자 장수인지, 요리사인지 알 필요가 없다. ‘증언하라’라는 메시지를 이해하면서 ‘증인’ 역할을 수행할 수 있는 수신자라면 어느 누구와도 협력이 가능하다. 따라서 송신자에게 영향을 주지 않고도 메시지를 수신할 객체의 타입을 자유롭게 추가할 수 있다. 이는 품질에 큰 영향을 미친다. 협력을 유연하게 변경할 수 있고, 협력이 수행되는 방식을 확장할 수 있고, 협력이 수행되는 방식을 재사용할 수 있다.

객체지향 용어를 이용해서 표현하면, 다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다. 다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다. 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들 수 있기 때문이다.

대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 메커니즘이라고 배운다. 하지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나온다. 클래스를 사용하지 않고도 객체의 속성과 행위를 표현할 수도 있다.

진정한 객체지향 패러다임으로의 도약은 개별적인 객체가 아니라 메시지를 주고 받는 객체들 사이의 커뮤니케이션에 초점을 맞출 때 일어난다.

책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다. 이 과정을 What/Who 사이클이라고 한다. 어떤 행위를 수행할 것인지를 결정한 후에 누가 그 행위를 수행할 것인지를 결정해야 한다는 뜻이다.

메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 한다. 이를 ‘묻지 말고 시켜라 스타일’ 또는 디미터의 법칙 (Law of Demeter)라고 한다. 

메시지를 결정하는 시점에서는 어떤 객체가 메시지를 수신할 것인지를 알 수 없기 때문에 메시지 송신자는 메시지를 수신할 객체의 내부 상태를 볼 수 없고, 따라서 메시지 중심 설계는 메시지 수신자의 캡슐화를 증진시킨다. 따라서 송신자와 수신자를 느슨하게 결합하게 한다. 따라서 송신자는 수신자의 객체에 관해 꼬치꼬치 캐물을 수 없다. (그래서 .을 통해 메소드 호출이 많은 코드 작성이 불가능한 것이겠구나)

메시지를 이해할 수 있다면 다양한 타입의 객체로 협력 대상을 자유롭게 교체할 수 있기 때문에 설계가 좀 더 유연해진다. 재사용 가능하고 확장 가능한 객체지향 설계를 구축하기 위한 핵심적인 도구인 다형성은 개별 객체가 아니라 객체들이 주고받는 메시지에 초점을 맞출 때 비로소 그 진가를 발휘하게 된다. 메시지를 중심으로 설계된 구조는 유연하고 확장 가능하며 재사용 가능하다.

메시지를 믿으면 자율적인 책임은 저절로 따라오게 된다.

인터페이스는 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치다.


**인터페이스의 특성**
1. 인터페이스의 사용법만 알면 대상의 내부 구조나 동작 방법을 몰라도 상호작용이 가능, 따라서 인터페이스는 내부의 복잡함을 감추고 사용에 필요한 최소한의 요소만 사용자에게 노출
2. 인터페이스가 변경되지 않고 내부 구성이나 작동 방식이 변경되는 것은 사용자에게 아무 영향도 미치지 않음.
3. 인터페이스만 동일하면 어떤 대상과도 상호작용이 가능하다.

인터페이스는 외부에서 접근 가능한 공개된 인터페이스와 내부에서만 접근 가능한 감춰진 인터페이스로 구분된다. 공개된 인터페이스를 공용 인터페이스라고 한다.

객체가 협력에 참여하기 위해 수행하는 메시지가 객체의 공용 인터페이스 모양을 암시한다. 이는 책임-주도 설계 방식의 What/Who 사이클과 관련이 깊으며, 이 때문에 메시지가 수신자의 인터페이스를 결정한다.

훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 이는 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확하게 분리하여 고려해야 한다는 것을 의미한다. 이를 **인터페이스와 구현의 분리 원칙**이라고 한다.

소프트웨어는 항상 변경되기 때문에, 변경해도 무방한 안전지대와 변경했을 때 외부에 영향을 미치는 위험지대를 구분하는 것이다.

객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 **캡슐화**라고 한다. 캡슐화는 두 가지 관점에서 사용된다.

1. 상태와 행위의 캡슐화 (데이터 캡슐화) : 상태와 행위를 한 데 묶은 후 외부에서 반드시 접근해야만 하는 행위만 골라 공용 인터페이스를 통해 노출
2. 사적인 비밀의 캡슐화: 객체는 외부의 객체가 자신 내부의 상태를 직접 관찰하거나 제어할 수 없도록 막기 위해 의사소통 가능한 특별한 경로만 외부에 노출
