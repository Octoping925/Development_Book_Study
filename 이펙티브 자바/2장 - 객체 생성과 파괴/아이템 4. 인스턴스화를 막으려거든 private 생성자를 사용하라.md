# 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

단순히 정적 메소드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것이다. 객체 지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기 때문에 그리 곱게 보이지는 않지만, 분명 나름 쓰임새가 있다.

예컨데 `java.lang.Math`와 `java.util.Arrays`가 그렇다. 이 둘은 인스턴스화할 수 없는 유틸리티 클래스다. 인스턴스화할 수 있는 클래스를 만들어야 할 이유가 전혀 없다면 이런 식으로 만들어도 된다.

또한, `java.util.Collections`처럼 특정 인터페이스를 구현하는 객체를 반환하는 정적 메소드를 모아놓은 클래스도 있다.

마지막으로, final 클래스와 관련한 메소드들을 모아둘 때도 사용한다. final 클래스를 상속해서 하위 클래스에 메소드를 넣는 것은 불가능하기 때문이다.

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한게 아니다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다. 이 기본 생성자는 클래스 바깥에서 접근할 수 있는 public 생성자가 되기 때문에, 이 클래스의 인스턴스를 만들 수 있다. 사용자는 이 생성자가 자동생성된 것인지 구분할 수 없기 때문에, 이 클래스의 인스턴스를 만들어 사용할 수 있다.

추상 클래스로 만드는 것으로는 이 문제를 해결할 수 없다. 추상 클래스는 인스턴스화할 수 없지만, 하위 클래스를 만들어 인스턴스화할 수 있다. 그리고 이런 하위 클래스는 상위 클래스의 생성자를 호출할 수 있기 때문에, 상위 클래스의 인스턴스를 만들 수 있다.

private 생성자를 추가하면 이 문제를 해결할 수 있다. private 생성자는 클래스 바깥에서 접근할 수 없기 때문에, 클래스의 인스턴스를 만들 수 없다. 따라서, 이 클래스의 인스턴스를 만들 수 없다.

이 방식은 상속을 불가능하게 하는 효과도 있다.
