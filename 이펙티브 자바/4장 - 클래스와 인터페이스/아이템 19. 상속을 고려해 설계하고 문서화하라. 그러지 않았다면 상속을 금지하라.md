# 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

상속을 고려한 설계와 문서화란 무엇인가?

## 상속을 고려한 설계와 문서화

메소드를 재정의하면 어떤 일이 일어나는지를 정확히 정리해서 문서로 남겨야 한다.

상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용)를 문서로 남겨야 한다.

API 문서의 메소드 설명 끝에서 종종 'Implementation Requirements'라는 절이 나온다. 이 절에는 메소드를 재정의할 때 지켜야 할 불변식이나, 재정의하지 않는 것이 좋은 이유 등을 설명한다.

하지만 이러면 '좋은 API 문서는 어떻게가 아닌 무엇을 하는지를 설명해야 한다'는 격언과 대치되는데, 상속이 캡슐화를 해치기 때문에 일어나는 안타까운 일이다.

내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다. 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스 내부 동작 과정 중간에 끼어들 수 있는 '훅(hook)'을 잘 선별하여 protected 메소드 형태로 공개해야 한다.

## 상속용 클래스를 시험하기

- 상속용 클래스를 만들 때는 그 클래스를 상속받은 하위 클래스를 만들어보아야 한다.

- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안 된다. 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 호출된다.

```java
public class Super {
    // 재정의 가능 메소드. 생성자 안에서 호출하면 안 된다.
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}

public class Sub extends Super {
    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    // 재정의 가능 메소드. 생성자에서 호출하면 안 된다.
    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

- `Cloneable`, `Serializable` 인터페이스는 상속용 설계를 더욱 어렵게 한다.

둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않다. 이 클래스를 확장하려는 프로그래머에게 엄청난 부담을 지우기 때문이다.

clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다.

- Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메소드를 제공한다면, 이 메소드들은 반드시 protected로 선언해야 한다.

## 정리

- 상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용)를 문서로 남겨야 한다.
- 클래스를 확장해야 할 명확한 이유가 없다면 상속을 금지하라.
- 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 하라.
