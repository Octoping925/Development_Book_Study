# 아이템 13. clone 재정의는 주의해서 진행하라

`Cloneable`은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스이지만, 아쉽게도 의도한 목적을 제대로 이루지 못했다.
가장 큰 문제는 `clone`이 선언된 곳이 `Object`라는 점이다. `Object`의 `clone` 메서드는 `protected`로 선언되어 있어, clone을 외부에서 호출할 수 없다는 점이다.

실무에서 Cloneable을 구현한 클래스는 clone 메소드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이루어지리라 기대한다. 이 기대를 만족시키려면 그 클래스와 모든 상위 클래스는 복잡하고, 강제할 수 없고, 허술하게 기술된 프로토콜을 지켜야만 하는데, 그 결과로 깨지기 쉽고 위험하고 모순적인 메커니즘이 탄생한다. 생성자를 호출하지 않고도 객체를 생성할 수 있게 되는 것이다.

## clone 메소드의 일반 규약

객체의 복사본을 생성해 반환한다.

- `x.clone() != x` 이다.
- `x.clone().getClass() == x.getClass()` 이다.
- `x.clone().equals(x)` 는 보통 참이지만 필수는 아니다.

## 정리

새 인터페이스를 만들 때는 `Cloneable`를 확장해서는 안되며, 새 클래스도 이를 구현해서는 안 된다.

final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별 다른 문제가 없을 때에만 드물게 허용해야 한다.

**복제 기능은 생성자와 팩토리를 이용하는게 최고**다.
