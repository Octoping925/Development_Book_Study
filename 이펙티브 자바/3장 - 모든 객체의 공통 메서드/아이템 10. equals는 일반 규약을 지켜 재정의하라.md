# 아이템 10. equals는 일반 규약을 지켜 재정의하라

equals 메소드는 재정의하기 쉬워보이지만 곳곳에 함정이 도사리고 있다.

문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않아, 자기 자신 이외의 인스턴스와는 모두 다르다고 판단하는 것이다.

## equals를 재정의하지 않아야 할 때

- **각 인스턴스가 본질적으로 고유하다.** 값을 표현하는 것 (VO)이 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다.
- **인스턴스의 논리적 동치성을 검사할 일이 없다.** 예를 들면 `java.util.regex.Pattern` 클래스는 같은 정규표현식을 나타내는지를 검사한다.
- **상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.** 예를 들면 대부분의 컬렉션 구현체는 `AbstractCollection`의 equals를 그대로 사용한다.
- **클래스가 `private` 또는 `package-private`이고 equals 메소드를 호출할 일이 없다.** 이런 클래스는 하위 클래스를 만들 수 없으므로 equals를 재정의할 일이 없다.

## `equals`를 재정의해야 하는 때

- **값 클래스의 경우.** (Integer, String 등의 VO) equals를 재정의하여 논리적 동치성을 확인하도록 정의하면, Map이나 Set의 원소로도 사용할 수 있다.

## equals를 재정의할 때는 일반 규약을 따르라

equals 메소드는 동치관계를 구현하며, 다음을 만족한다.

- **반사성**: null이 아닌 모든 참조 값 x에 대해, `x.equals(x)`는 `true`다.
- **대칭성**: null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`가 true면 `y.equals(x)`도 true다.
- **추이성**: null이 아닌 모든 참조 값 x, y, z에 대해, `x.equals(y)`가 true고 `y.equals(z)`도 true면 `x.equals(z)`도 true다.
- **일관성**: null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
- **null-아님**: null이 아닌 모든 참조 값 x에 대해, `x.equals(null)`은 false다.

## equals를 재정의할 때 주의할 점

1. 구체 클래스를 확장해 새로운 값을 추가하면서 `equals` 규약을 만족시킬 방법은 존재하지 않는다.
2. 클래스가 불변이든 가변이든, equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다. (URL과 IP 주소를 비교하는 예시)

## 양질의 equals 메소드 구현 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.
5. 위의 모든 검사를 통과했다면 대칭적인지, 추이성이 있는지, 일관적인지 자문한다.
6. equals를 재정의했다면 hashCode도 반드시 재정의해야 한다.
7. 너무 복잡하게 해결하려 들지 말자. (보통 필드들의 동치성만 검사해도 충분하다.)
8. Object 외의 타입을 매개변수로 받는 equals를 정의하지 말자.
